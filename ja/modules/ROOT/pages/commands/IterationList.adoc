= IterationList コマンド
:page-en: commands/IterationList
ifdef::env-github[:imagesdir: /ja/modules/ROOT/assets/images]

IterationList( <関数>, <開始値>, <反復回数> )::
  長さ__n+1__（_n_ = 反復回数）のリストを与え，その要素は開始値から始まる関数の反復である．
 
[EXAMPLE]
====

　`++f(x) = x^2++` を定義した後， `++IterationList(f, 3, 2)++` を実行すると，リスト： __{3, 9, 81}__が出力される．

====

このコマンドを使えば， _a~k+1~_ が _a~k~_ 
  と__k__に依存するような数列を定義することもできる．入力関数__f__が2変数の関数で，開始値が2つの数値__{s,
  a~s~}__のリストとすると，出力リストは__a~s~__,_a~s+1~_,....,__a~s+n~__という数値の並びになる．ここで，_k>s_
  のとき，__a~k+1~=f(k, a~k~)__という関係が成り立つ．



[EXAMPLE]
====

`++f(k,a)=(k+1)*a++` と定義すると，この関数は階乗の再帰的定義に対応する．コマンド `++IterationList(f, {3, 6}, 4)++`
は，この関数を初期値{3, 6}から4回繰り返し適用した結果のリスト__{6, 24, 120, 720, 5040}__ を出力する．

====

IterationList( <式>, <変数>, ..., <開始値>, <反復回数> )::
  __n__回の反復 (__n__は反復回数）を行った結果の長さ _n+1_
  のリストを出力する．このリストの要素は，与えられた開始値から始まる式の反復である．各反復では，式中の変数がリストの直前の要素に置き換えられる．変数の数だけ開始値が必要であり，それが不足している場合の結果は__未定義__になる．

[EXAMPLE]
====

_A_,__B__を点とする．コマンド `++IterationList(Midpoint(A, C), C, {B}, 3)++` は，点__C__を初期値Bから始めて，点__A__との中点を次々に求めることで，値__C__~0~
= _B_,   __C__~1~ = _Midpoint_(_A_, __C__~0~),   __C__~2~ = _Midpoint_(_A_, __C__~1~),   __C__~3~ = _Midpoint_(_A_,
__C__~2~) を内部的に計算する．そして，{__C__~0~, __C__~1~, __C__~2~, __C__~3~}というリストを出力する．したがって，_A_ =
(0,0)，_B_ = (8,0)の場合，結果は{(8,0), (4,0), (2,0), (1,0)}となる．

====

[EXAMPLE]
====

　_f_~0~ ,　_f_~1~ を数値とする．`++IterationList(a + b, a, b, {f_0, f_1}, 5)++`
は，出力されるのリストの最初の2つの値を開始値として設定する．その後，値は__f__~2~ = __f__~0~ + __f__~1~,   __f__~3~ =
__f__~1~ + __f__~2~,   __f__~4~ = __f__~2~ + __f__~3~,   __f__~5~ = __f__~3~ +
__f__~4~という式に従って計算される．したがって，_f_~0~ = _f_~1~ = 1の場合，結果は{1, 1, 2, 3, 5, 8}となる．

====



[NOTE]
====

現在，CASでは最初の構文のみがサポートされている．

====

[NOTE]
====

こちらも参照： xref:/commands/Iteration.adoc[Iteration コマンド].

====
