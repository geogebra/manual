= Commande ItÃ©rationListe
:page-en: commands/IterationList
ifdef::env-github[:imagesdir: /fr/modules/ROOT/assets/images]

ItÃ©rationListe( <Fonction f>, <Valeur dÃ©part stem:[x_0]>, <Nombre n> )::
  Liste _L_ de longueur _n+1_ dont les Ã©lÃ©ments sont les images itÃ©ratives par _f_ de la valeur stem:[x_0].

[EXAMPLE]
====

*ExemplesÂ :*

* AprÃ¨s avoir dÃ©fini `++f(x) = x^2++` la commande `++ItÃ©rationListe(f, 3, 2)++` retourne la liste _L = \{3, 9, 81}_
(c'est-Ã -dire _\{3,3^2^,(3^2^)^2^}_).
* on peut utiliser cette commande pour dÃ©finir une suite rÃ©currente oÃ¹ _a~k+1~_ dÃ©pend de _a~k~_ et _k_. Ã€ partir d'une
fonction _f_ de deux variables avec comme Valeur dÃ©part une liste de deux nombres__\{s, a~s~}__, la liste crÃ©Ã©e sera
celle des valeurs _a~s~_, _a~s+1~_ ,....,_a~s+n~_ dans laquelle pour _k>s_ on a _a~k+1~=f(k, a~k~)_.

AprÃ¨s avoir dÃ©fini `++f(k,a)=(k+1)*a++`, qui correspond Ã  la dÃ©finition rÃ©cursive de factorielle. La commande
`++ItÃ©rationListe(f, {3, 6}, 4)++` retournera la liste _\{6, 24, 120, 720, 5040}_

====

ItÃ©rationListe( <Expression>, <Nom Variable>, ..., <Liste Valeurs dÃ©part>, <Nombre d'itÃ©rations> )::
  Construit la liste de longueur _n+1_ dont les Ã©lÃ©ments sont les images itÃ©ratives de l'expression en partant de la
  valeur de dÃ©part. Les variables de l' expression sont remplacÃ©es par les derniers Ã©lÃ©ments de la liste Ã  chaque
  itÃ©ration. Il doit y avoir au moins autant de valeurs de dÃ©part qu'il y a de variables, sinon le rÃ©sultat est _non
  dÃ©fini_.

[EXAMPLE]
====

*ExemplesÂ :* Soit A et B deux points. Alors `++ItÃ©rationListe(MilieuCentre(A, C), C,{B},3)++` calcule

* C~0~=BÂ ;
* C~1~=MilieuCentre(A, C~0~)Â ;
* C~2~=MilieuCentre(A, C~1~)Â ;
* C~3~=MilieuCentre(A, C~2~)

et retourne \{C~0~, C~1~, C~2~, C~3~}. Ainsi pour `++A=(0,0)++` et `++B=(8,0)++` le rÃ©sultat sera \{(8,0), (4,0), (2,0),
(1,0)}.

====

{empty}[.kcode]#SaisieÂ :# Voir aussi la *commande* : xref:/commands/ItÃ©ration.adoc[ItÃ©ration]

[NOTE]
====

*image:18px-Bulbgraph.png[Note,title="Note",width=18,height=22] IdÃ©eÂ :* Utilisation avec des suites numÃ©riques

* [.underline]#Suites arithmÃ©tiques a(n+1) = a(n) + r#

avec par exemple a(0) = 1 et r = 3 `++ItÃ©rationListe(x+3, 1, 4)++` retourne _\{1, 4, 7, 10, 13}_

* [.underline]#Suites gÃ©omÃ©triques g(n+1) = q x g(n)#

avec par exemple g(0) = 1 et q = 3 `++ItÃ©rationListe(3x, 1, 4)++` retourne _\{1, 3, 9, 27, 81}_

* [.underline]#Suite de FibonnacciÂ :#

Soit f_0 et f_1 deux nombres. `++ItÃ©rationListe(a+b, a,b,{f_0,f_1},5)++` affecte aux 2 premiers Ã©lÃ©ments du rÃ©sultat les
deux valeurs de dÃ©part. Ensuite les valeurs sont calculÃ©es comme suitÂ :

* f~2~=f~0~+f~1~Â ;
* f~3~=f~1~+f~2~Â ;
* f~4~=f~2~+f~3~Â ;
* f~5~=f~3~+f~4~.

et retourne \{f~0~, f~1~, f~2~, f~3~, f~4~, f~5~ }. Ainsi pour `++f_0=1++` et `++f_1=1++` le rÃ©sultat sera
\{1,1,2,3,5,8}.

* [.underline]#Suites de Collatz ou SyracuseÂ :#

`++ItÃ©rationListe(Si(floor(x / 2) â‰Ÿ x / 2, x / 2, 3x + 1), 14, 8)++` retourne _\{14, 7, 22, 11, 34, 17, 52, 26, 13}_ les
_8_ premiers termes de cette suite de premier terme _14_

* [.underline]#Suites rÃ©currentes avec prÃ©sence de _n_ dans la formuleÂ :#

ğŸ¦Soit la suite \{7, 71, 712, 7123, 71234, 712345}, une interprÃ©tationÂ : le premier terme, u~0~, est 7, le suivant, u~1~,
10 fois 7 augmentÃ© de 1, le suivant du suivant, u~2~, 10 fois 71 augmentÃ© de 2 .../...

on va *dÃ©finir* une fonction de 2 variables f(n,x) ([.underline]#*le _n_ Ã©tant la 1Ã¨re*#) `++f(n, x) = 10x + n ++`et la
validation de `++ItÃ©rationListe(f, {1, 7}, 5)++` exÃ©cutant les itÃ©rations de la fonction _f_ Ã  partir de __n__=*1* pour
une valeur d'image de dÃ©part de *7*, retournera la liste des 6 nombres prÃ©sentÃ©s.

====

____________________________________________________________

image:32px-Menu_view_cas.svg.png[Menu view cas.svg,width=32,height=32] *Calcul formel*Â :

Cette commande fonctionne Ã  l'identique dans la fenÃªtre Calcul formel
